# 250915

n = int(input())

count = 0
while n >= 5:
    count += n // 5  
    n //= 5           
print(count)


# ===================
# 문제: N! (팩토리얼)을 십진수로 썼을 때, 뒤에서부터 연속되는 0의 개수 구하기
# 핵심 아이디어:
#   - 뒤의 0 하나는 곱셈에서 10이 한 번 만들어졌다는 의미
#   - 10 = 2 * 5
#   - N!을 소인수분해하면 2의 개수 > 5의 개수 (짝수들이 많아서 2는 항상 충분)
#   - 따라서 '뒤의 0의 개수' = 'N! 안에 5가 몇 번 등장하는가(=5의 지수)' 와 동일
#
# 예) N=10
#   10! = 10*9*8*...*2*1
#   5의 배수: 5, 10(=2*5) -> 최소 5가 2번 들어 있음 => 뒤의 0은 2개
#
# 25(=5^2) 같은 수는 5를 두 번 포함하므로 '추가로 한 번 더' 세야 함.
# 일반화하면:
#   floor(N/5) + floor(N/25) + floor(N/125) + ... (5^k <= N 인 동안)
#
# 아래 while문은 바로 이 합을 효율적으로 계산함:
#   1) count += n // 5         -> 모든 5의 배수 개수
#   2) n //= 5 (n를 5로 나눔)  -> 다음 루프에서 (25의 배수 개수) 더하기
#   3) 다시 n //= 5            -> 125의 배수 개수 더하기 ...
# 이렇게 반복하면 floor(N/5) + floor(N/25) + ... 를 한 번에 구할 수 있음.

n = int(input().strip())  # 정수 N 입력 (0 <= N), 0! = 1 이므로 뒤의 0은 당연히 0개

count_zeros = 0           # 뒤의 0 개수를 누적할 변수

# n이 5 이상인 동안만 5의 배수를 셀 의미가 있음
while n >= 5:
    # 현재 n에서 5의 배수 개수를 한 번에 더함
    # 예를 들어 N=100이면 첫 턴에 100//5 = 20 (5의 배수가 20개 존재)
    count_zeros += n // 5

    # n을 5로 나눠서 스케일을 줄임
    # 다음 턴에는 (25의 배수), 그 다음엔 (125의 배수) ... 를 세게 됨
    # 예: N=100 -> n=100//5=20 -> 다음 턴에 count += 20//5=4 (25의 배수 4개)
    n //= 5

# 최종적으로 누적된 count_zeros가 뒤에서부터 연속된 0의 개수
print(count_zeros)
