# 251129

from collections import deque

N = int(input())
q = deque(range(1, N + 1))

while len(q) > 1:
    q.popleft()
    q.append(q.popleft())

print(q[0])


##
from collections import deque   # deque 자료구조를 쓰기 위해 불러온다 (큐 역할)

N = int(input())                # 카드 개수 N 입력 (1부터 N까지 카드가 있다고 가정)

# 1부터 N까지 숫자를 차례대로 담은 deque 생성
# range(1, N+1)은 1,2,3,...,N 까지 숫자를 만들어줌
q = deque(range(1, N + 1))

# 카드가 1장 남을 때까지 계속 반복
while len(q) > 1:
    q.popleft()                 # 1) 맨 위 카드 버리기 (큐의 앞에서 하나 꺼내서 버림)

    # 2) 그 다음 카드도 앞에서 꺼내서 (popleft)
    #    그 카드를 다시 맨 뒤에 붙인다(append) → "위에서 빼서 아래로 보내기"
    q.append(q.popleft())

# 반복이 끝나면 카드가 1장만 남아 있음
# 그 남은 카드(맨 앞 카드)를 출력
print(q[0])


# 예를 들어 N = 6이면,
# 초기 상태: q = [1, 2, 3, 4, 5, 6]

# 1버림 --> [2, 3, 4, 5, 6]
# 2를 뒤로 → [3, 4, 5, 6, 2]

# 3버림 --> [4, 5, 6, 2]
# 4를 뒤로 → [5, 6, 2, 4]

# 5버림 --> [6, 2, 4]
# 6을 뒤로 → [2, 4, 6]

# 2버림 --> [4, 6]
# 4를 뒤로 --> [6, 4]

# 6버림 --> [4]

# 그래서 마지막 카드 = 4 --> print(q[0]) 에서 4 출력

# ====================================================

# deque 없는 방법
N = int(input())

p = 1
while p * 2 <= N:
    p *= 2

if N == p:
    print(N)
else:
    print((N - p) * 2)


##
# N이 2의 제곱수라면 정답은 그냥 N
# N이 2의 제곱수가 아니면
#    N보다 작거나 같은 가장 큰 2의 제곱수를 p라 두고
#    답 = (N - p) * 2



N = int(input())   # 카드 개수 입력

p = 1              # p를 1(= 2^0)로 시작
# p를 N 이하에서 가장 큰 2의 거듭제곱으로 만들기 위한 반복
while p * 2 <= N:
    p *= 2         # p = p * 2  → 1, 2, 4, 8, 16, ... 이런 식으로 증가

# 여기까지 오면 p는 "N 이하인 가장 큰 2의 거듭제곱"이 된다.

if N == p:
    # 만약 N 자체가 2의 제곱이면
    # 규칙상 마지막 남는 카드는 N 그대로이다.
    print(N)
else:
    # N이 2의 제곱이 아니라면
    # (N - p)를 두 배 한 값이 마지막 카드 번호가 된다.
    print((N - p) * 2)



# p를 1에서 시작해서 2배씩 키운다 (1, 2, 4, 8, 16, ...)
# p * 2 <= N 조건이 깨질 때까지 반복 
# 즉, N을 넘지 않는 최대 2의 거듭제곱이 p에 저장됨

# if N == p
# N이 딱 2의 거듭제곱이면 정답은 N

# else: print((N - p) * 2)
# 아니면 남은 수 * 2가 마지막 카드